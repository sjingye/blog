# 数据结构与算法之美

大 O 时间复杂度实际上并不具体表示代码真正的执行时间，而是表示代码执行时间随数据规模增长的变化趋势，所以，也叫作渐进时间复杂度(asymptotic time complexity)，简称时间复杂度。

空间复杂度全称就是渐进空间复杂度(asymptotic space complexity)，表示算法的存储空间与数据规模之间的增长关系。

复杂度也叫渐进复杂度，包括时间复杂度和空间复杂度，用来分析算法执行效率与数据规模之间的增长关系，可以粗略地表示，越高阶复杂度的算法，执行效率 越低。常见的复杂度并不多，从低阶到高阶有:O(1)、O(logn)、O(n)、O(nlogn)、O(n2 )。等你学完整个专栏之后，你就会发现几乎所有的数据结构和算法的复杂度都跑不出这几个。

**数组**
现在我们来思考开篇的问题:为什么大多数编程语言中，数组要从 0 开始编号，而不是从 1 开始呢?

从数组存储的内存模型上来看， 下标 最确切的定义应该是 偏移(“offset” ) 。前面也讲到，如果用 a 来表示数组的首地址，a[0]就是偏移量为 0 的位置 址，a[k]就表示偏移 k 个 type_size 的位置，所以计算 a[k]的内存地址只需要用这个公式:

```
a[k]_address = base_address + k * type_size
```

但是，如果数组从 1 开始计数，那我们计算数组元素 a[k]的内存地址就会变为:

```
a[k]_address = base_address + (k-1)\*type_size
```

对比两个公式，我们不难发现，从 1 开始编号，每次随机访问数组元素都多了一次减法运算，对于 CPU 来说，就是多了一次减法指令。
(对文中示例的无限循环有疑问的同学，建议去查函数调用的栈桢结构细节(操作系统或计算机体系结构的教材应该会讲到)。)

**栈**
为什么函数调用要用“栈”来保存临时变量呢?用其他数据结构不行吗?

其实，我们不一定非要用栈来保存临时变量，只不过如果这个函数调用符合后进先出的特性，用栈这种数据结构来实现，是最顺理成章的选择。
从调用函数进入被调用函数，对于数据来说，变化的是什么呢?是作用域。所以根本上，只要能保证每进入一个新的函数，都是一个新的作用域就可以。而 要实现这个，用栈就非常方便。在进入被调用函数的时候，分配一段栈空间给这个函数的变量，在函数结束的时候，将栈顶复位，正好回到调用函数的作用域内。
